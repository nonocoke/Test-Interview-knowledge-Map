
## 资损 (资金损失)

资损通常来讲是指支付场景下的资金损失

- 用户角度：多扣用户款导致用户资金损失，此问题一般需要通过客服等渠道反馈，可以把多的钱退给用户，但是很大程度上损失了用户体验；
- 公司角度：主要是多出金、多出货、多充值等情况，一般这种损失很难追回，这就是实打实的产生了资产损失。

--

1. 线下 (测试手段保障资金安全)
2. 线上 (监控-发现问题、故障-止损能力)

资损类常见故障
    
    1. 有正确的输入，错误的输出：比如系统与系统之间的金额存储单位不一致，或者自己处理金额正确，传输给下游的金额错误，导致后面交易金额错误
    2. 上下游系统的数据不一致：该处理的没处理，该到达终态的单据没有到达终态
    3. 幂等控制失效，多扣款或多入账
    4. 系统内部逻辑错误，无对外输出
    5. 人工修复异常场景，产生资损

防控资损体系

    1. 发现问题的实时性，减少故障的影响面
    2. 信息流一致性两两比对、资金流平衡型检查
    3. 全方位监控：业务触发、人工变更资金检测、历史数据检测
    4. 检测的准确性，无误报
    5. 和支付链路解藕，不影响主链路

业务资金规则

* 支付金额-退款金额应该==结算金额
* 退款金额不能大于支付金额
* 凭证支付、现金支付无资金流类型不用调用账务
* 支付和账务之间会经过结算的处理
* 账务累计出入金额和支付的金额应该要相等

## 幂等

__接口幂等性__ 是指用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。接口的可重复调用（包括时间和空间上两个维度）多余的调用对系统的数据一致性不造成破坏。

- insert操作，这种情况下多次请求，可能会产生重复数据
- update操作
    - 单纯的更新数据，没有问题。比如：update user set status=1 where id=1
    - 如果更新时还有计算，多次请求，可能会导致数据错误。比如：update user set status=status+1 where id=1

### 1. MVCC（多版本并发控制）

乐观锁的一种实现，用于在数据库并发访问时的情况。当数据更新时需要去判断版本号是否一致，如果不一致，则无法对数据进行更新

Id可进一步设为主键或唯一索引，因为这样是行锁，否则更新操作时会锁表。乐观锁在对已有数据进行更新时既能保证效率，又能保证幂等

### 2. 去重表

利用数据库表单的特性来实现幂等。

将订单号orderId设为去重表的唯一索引，每次请求支付都根据订单号向去重表中插入一条数据，只有插入成功才继续执行支付操作，相当于在事务的开始阶段加锁。

考虑两种失败的情况：

- Insert去重表失败，事务回滚，无任何影响；
- Insert去重表成功，支付业务操作失败，事务回滚，删除之前插入去重表的记录，无任何影响；

事务的幂等性是可以保持的，避免了单个订单同时多次进行支付的情况

### 3. 分布式锁

与去重表思路相同，只是将对数据库的的访问转移到了对缓存（如redis）的访问，提高了效率

1. 订单发起支付请求，支付系统会去redis缓存中查询是否存在该订单号orderId的key，
    - 如果不存在，则向redis增加key为订单号，然后开始实际支付操作；
    - 如果查询到存在该订单号的key，则不进行实际支付操作。
2. 无论支付操作成功或失败，在支付操作结果返回后，在缓存中删除该订单号key



tip

    - 乐观锁 乐观锁不在数据库上加锁，任何事务都可以对数据进行操作，在更新时才进行校验，乐观锁通常是通过在表中增加一个版本(version)或时间戳(timestamp)来实现，其中，版本最为常用

    - 悲观锁 悲观锁认为被它保护的数据是极其不安全的，每时每刻都有可能变动，一个事务拿到悲观锁后，其他任何事务都不能对该数据进行修改，只能等待锁被释放才可以执行。 (数据库中的行锁，表锁，读锁，写锁均为悲观锁)
        - Innodb默认使用的是行锁。而行锁是基于索引的，因此要想加上行锁，在加锁时必须命中索引，否则将使用表锁


    - 防重设计主要为了避免产生重复数据，对接口返回没有太多要求
    - 而幂等设计除了避免产生重复数据之外，还要求每次请求都返回一样的结果




算法题

1. [合并有序区间 lc56](https://leetcode-cn.com/problems/merge-intervals/)
    * sorted()，比较前一区间end、后一区间first

2. 多边形内找出 10w 个不重复的点
    * 射线法，如果测试点的两边点的个数都是奇数个则该测试点在多边形内

3. 给定 3 个字符串，找出长度最长的两个并打印 (follow up: N个字符串找出最长的2个)
    1. min/max/sorted
    ```python3
    _max = max(strs, key=len)
    _max_2 = max(strs.remove(_max), key=len)
    ```
    2. [数组中 k大问题](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)
 
4. 字符串(含数字)abc1123ca ，逆序打印每个字符出现的次数

    ```python3
    from collections import Counter
    Counter(strs).most_common(2)
    ```
    1. 字典存储key: counts
    2. 按 value 排序打印
        - sorted(d.items(), key=lambda x: x[1], reverse=True)

5. [零钱兑换 II lc518](https://leetcode-cn.com/problems/coin-change-2/)
    ```python3
    class Solution:
        def change(self, amount: int, coins: List[int]) -> int:
            dp = [1] + [0] * amount
            for coin in coins:
                for j in range(coin, amount + 1):
                    dp[j] += dp[j - coin]
            return dp[-1]
    ```

测试题

1. 如何用 1个byte 测试三角形，并写出测试用例
2. web-pay-bank，写出测试用例
3. 测试支付接口

sql

1. left join
2. group by having

shell
1. 输出出现的单词次数

    ```bash
    cat 1.txt | xargs -n1 | sort | uniq -c | grep abc | awk '{print $1}'
    ```
